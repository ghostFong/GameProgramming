<!DOCTYPE html>

<html>

<head>
<style>
	body {
	  background-color: #fff;
	  color: #111;
	  margin: 0px;
	  overflow: hidden;
	font-family: Monospace;
	  font-size: 20px;
	}
	
	#info {
	  position: absolute;
	  top: 0px;
	  width: 100%;
	  padding: 5px;
	  text-align: center;
	  color: #ffff00
	}
</style>
</head>

<body> 
<div id="info">
  Hw5a Helper <br>
  <!-- button -->
<button id="play" style="width:20%">Play</button>
  <button id='reset'>
  Reset
  </button>
  
</div>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://jyunming-chen.github.io/game3js/js/ccdsys.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<!-- music source from https://www.tam-music.com/ -->
<audio id="puckCollisionSuond" style="display:none">
<source src="https://www.tam-music.com/se/menu/wave/short01d.wav" type='audio/wav'>
</audio>
<audio id="wallCollisionSuond" style="display:none">
<source src="https://www.tam-music.com/se/menu/wave/cursor5.wav" type='audio/wav'>
</audio>
<audio id="relaxed" autoplay loop style="display:none">
<source src="https://www.tam-music.com/mp3/tamhe15.mp3"  type='audio/mp3'>
</audio>

<script>

$('#play').click(function() {
  isPaused = !isPaused;
  if (isPaused) {
    $('#play').text('Play')
    relaxed.pause()
  } else {
    $('#play').text('Pause')
    relaxed.play()
  }
});

var scene, renderer, camera;

var raycaster;
var mouse = new THREE.Vector2();
var pickables = [];

/////////////////////////
var playerArm;
var opponentArm;
var end;
var end2;
var endPos, lastPos;
var endPos2, lastPos2;
var setLength = 350;
var myGoal, opponentGoal;
var zz = 0, sign = 1;
const wallSet = setLength/2;
const R = 14;
var eps = 1e-3; //0.001
var cR = 1.0;
var viewLine;

//voice
var isDimming = false,
  soundVal = 1.0;
var isPaused = true;
var relaxed, puckCollisionSuond, wallCollisionSuond;

$('#reset').click (function(){
	puck.pos.set (0,5,250);
	puck.vel.set (2,0,2);
});

// use JavaScript Object
// no need to make it a CLASS (one of a kind)

class threePosition {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
}


var puck = {
	pos: new THREE.Vector3(),
    vel: new THREE.Vector3(),
    
    init: function () {
  		this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 5, 20), 
  		          new THREE.MeshNormalMaterial());
	    this.pos.set (0,2.5,250);
		puck.vel.set (0,0,0);
	    this.mesh.position.copy (this.pos); 		 
    },
    
    update: function(dt) {
  	    this.pos.add (this.vel.clone().multiplyScalar(dt));
  	    this.vel.multiplyScalar (0.96);  // damp to ZERO

  	    this.mesh.position.copy (this.pos);
    }
}

var playerer = {  
    theta1: 0,
    theta2: 0,
    target: new THREE.Vector3(),

	init: function() {
      let playerArm = new THREE.Object3D();

	  this.link1 = makeLink (60)
      this.link2 = makeLink (90)

	  playerArm.add (this.link1);
      this.link1.add (this.link2);
	  this.link1.position.set (0,10,0);
      this.link2.position.set (60,0,0);
	  
	  //this.link1.rotation.y = Math.PI/2;

      // base
      let cyl_geom = new THREE.CylinderGeometry(10, 10, 6, 32);
      let cyl_mat = new THREE.MeshBasicMaterial({
        color: 0xff2211
      });
      let base = new THREE.Mesh(cyl_geom, cyl_mat);
      playerArm.add(base);
	  //playerArm.position.y = 2.5;
	  //playerArm
	  
	  return playerArm;    
    },

	// ccdSys: to be added later

	update: function (thetas) { // pass jointAngleArray
    	this.theta1 = thetas[0]
        this.theta2 = thetas[1]
		this.link1.rotation.y = this.theta1;
  		this.link2.rotation.y = this.theta2;    
    }

}

var opponent = {  
    theta1: 0,
    theta2: 0,
    target: new THREE.Vector3(),

	init: function() {
      let opponentArm = new THREE.Object3D();

	  this.link1 = makeLink (60)
      this.link2 = makeLink (90)

	  opponentArm.add (this.link1);
      this.link1.add (this.link2);
	  this.link1.position.set (0,10,0);
      this.link2.position.set (60,0,0);
	  //this.link1.rotation.y = -Math.PI;
      // base
      let cy2_geom = new THREE.CylinderGeometry(10, 10, 6, 32);
      let cy2_mat = new THREE.MeshBasicMaterial({
        color: 0xff2211
      });
      let base2 = new THREE.Mesh(cy2_geom, cy2_mat);
      opponentArm.add(base2);
	  //opponentArm.position.y = 2.5;
	  //opponentArm.rotation.y = -Math.PI;
	  
	  return opponentArm;    
    },

	// ccdSys: to be added later

	update: function (thetas) { // pass jointAngleArray
    	this.theta1 = thetas[0]
        this.theta2 = thetas[1]
		this.link1.rotation.y = this.theta1;
  		this.link2.rotation.y = this.theta2;    
    }

}

//wall
class Wall {
  constructor(position, size) {
    this.obj = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), new THREE.MeshPhongMaterial({
      color: 'lightgrey',
      transparent: true,
      opacity: 0.6
    }));
    this.obj.position.set(position.x, position.y, position.z);
    let tmp = 0;
    if (position.x == -wallSet || position.z == (-wallSet*2)) {
      tmp = (-wallSet + 1) + R;
    } else tmp = (wallSet - 1) - R;
    if (position.x == -wallSet || position.x == wallSet) {
      this.point = new THREE.Vector3(tmp, 0, 0);
      this.normal = new THREE.Vector3(-1 * tmp / Math.abs(tmp), 0, 0);
      if (position.x > 0 && position.z == 0) {
        this.obj.rotation.y = -Math.PI;
      }
    } else {
      this.point = new THREE.Vector3(0, 0, (tmp*2));
      this.normal = new THREE.Vector3(0, 0, -1 * (tmp*2) / Math.abs((tmp*2)));
    }
    scene.add(this.obj);
  }
}


init();
animate();

////////////////////////////////////////////////////////
// forward kinematics
function fk (theta, joints) {  // all memory assumed in place
  joints[0].set (0,0,0);
  
  var localzero = new THREE.Vector3(0, 0, 0);
  var m = new THREE.Matrix4();
  m.makeRotationY(theta[0]);
  m.multiply(new THREE.Matrix4().makeTranslation(60, 0, 0));
  localzero.applyMatrix4(m);
  joints[1].copy(localzero);

  localzero.set(0, 0, 0);
  m.multiply(new THREE.Matrix4().makeRotationY(theta[1]));
  m.multiply(new THREE.Matrix4().makeTranslation(90, 0, 0));
  localzero.applyMatrix4(m);
  joints[2].copy(localzero);
  
}

////////////////////////////////////////////////////////////////
function init() {

  puckCollisionSuond = document.getElementById('puckCollisionSuond');
  wallCollisionSuond = document.getElementById('wallCollisionSuond');
  relaxed = document.getElementById('relaxed');
  
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.set (0,260,720);
  camera.lookAt(new THREE.Vector3(0, 0, 0));
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', onWindowResize, false);

  /////////////////////////////////////////////////////////////////////
  let plane = new THREE.Mesh(new THREE.PlaneGeometry(setLength, (setLength*2)), new THREE.MeshBasicMaterial({
    color: 0x222222,
    side: THREE.DoubleSide
  }));
  plane.rotation.x = -Math.PI / 2;
  plane.position.y = -1.5;
  scene.add(plane);
  //plane.rotation.x = -Math.PI / 2;
  pickables = [plane];

  raycaster = new THREE.Raycaster();
  document.addEventListener('mousemove', onDocumentMouseMove, false);
  
  
  /////////////////////////////////////////////
  //add walls
  walls = [
    new Wall(new threePosition(-wallSet, 25, 0), new threePosition(10, 50, (wallSet * 4) + 10)),
    new Wall(new threePosition(wallSet, 25, 0), new threePosition(-10, 50, (wallSet * 4) + 10)),
    new Wall(new threePosition(0, 25, (wallSet*2)), new threePosition((wallSet * 2) - 10, 50, 10)),
    new Wall(new threePosition(0, 25, (-wallSet*2)), new threePosition((wallSet * 2) - 10, 50, 10))
  ]
  
  /////////////////////////////////////////////
  puck.init();
  playerArm = playerer.init();
  scene.add (puck.mesh, playerArm);  
  
  opponentArm = opponent.init();
  scene.add (puck.mesh, opponentArm);  
  
  end = new THREE.Mesh (new THREE.CylinderGeometry (14,14,5,32), new THREE.MeshBasicMaterial({color:'purple'}));
  scene.add (end);
  //end.position.y = 2.5;
  //
  end2 = new THREE.Mesh (new THREE.CylinderGeometry (14,14,5,32), new THREE.MeshBasicMaterial({color:'blue'}));
  scene.add (end2);
  
  //goal
  //myGoal = new THREE.BoxGeometry( 0, 25, 0 );
  //const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
  //const cube = new THREE.Mesh( geometry, material );
  myGoal = new THREE.Mesh (new THREE.BoxGeometry (60,25,0), new THREE.MeshBasicMaterial({color:'red'}));
  scene.add( myGoal );
  myGoal.position.z = setLength;
  myGoal.position.y = 25/2;
  
  
  opponentGoal = new THREE.Mesh (new THREE.BoxGeometry (60,25,0), new THREE.MeshBasicMaterial({color:'GoldenRod'}));
  scene.add( opponentGoal );
  opponentGoal.position.z = -setLength;
  opponentGoal.position.y = 25/2;
  
  viewLine = new THREE.Mesh (new THREE.BoxGeometry (340,0,20), new THREE.MeshBasicMaterial({color:'pink'}));
  scene.add( viewLine );
  viewLine.rotation.y = -Math.PI;
  
  
  endPos = new THREE.Vector3();
  lastPos = new THREE.Vector3();
  
  //
  endPos2 = new THREE.Vector3();
  lastPos2 = new THREE.Vector3();
  
  //playerArm.position.set (0,0,50);
  
  //opponentArm.position.set (0,0,50);
  // setting ccdSys
  playerer.ccdSys = new CCDSys (fk)
  
  // axes are in local frame of player arm
  playerer.ccdSys.setCCDAxis (new THREE.Vector3(0,1,0), 0)
  playerer.ccdSys.setCCDAxis (new THREE.Vector3(0,1,0), 1, -3.1, -0.01)  
  
  // setting ccdSys
  opponent.ccdSys = new CCDSys (fk)
  
  // axes are in local frame of player arm
  opponent.ccdSys.setCCDAxis (new THREE.Vector3(0,1,0), 0)
  opponent.ccdSys.setCCDAxis (new THREE.Vector3(0,1,0), 1, -3.1, -0.01) 
}

function makeLink(length) {
  var oneLink = new THREE.Object3D();
  var mesh = new THREE.Mesh(new THREE.BoxGeometry(length, 10,10), new THREE.MeshNormalMaterial());
  oneLink.add(mesh);
  mesh.position.set(length/2, 0, 0);
  return oneLink;
}

function onWindowResize() {
  let width = window.innerWidth;
  let height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
}

function animate() {
  
  requestAnimationFrame(animate);
  update()
  render();
  
  relaxed.volume = soundVal;
  
  
  let dt = 0.1;

  // collision detection
  if (endPos.distanceTo (puck.pos) < (R + R)) {
  	 //console.log ('hit');
  	 puck.vel.copy (endPos.clone().sub(lastPos).divideScalar(dt));
	 endPos.copy(lastPos);
	 document.getElementById('puckCollisionSuond').play();
  }
  lastPos.copy (endPos);


  if (endPos2.distanceTo (puck.pos) < (R + R)) {
  	 //console.log ('hit');
  	 puck.vel.copy (endPos2.clone().sub(lastPos2).divideScalar(dt));
	 endPos2.copy(lastPos2);
	 document.getElementById('puckCollisionSuond').play();
  }
  lastPos2.copy (endPos2);
  
  for (i = 0; i < walls.length; i++) {
    let wall = walls[i];
	if(puck.pos.clone().sub(wall.point).dot(wall.normal) < eps + R){
	var vN = wall.normal.clone().multiplyScalar(puck.vel.dot(wall.normal));
    var vT = puck.vel.clone().sub(vN);
    puck.vel.copy(vT.add(vN.multiplyScalar(-cR)));
    puck.pos.add(wall.normal.clone().multiplyScalar(R - puck.pos.clone().sub(wall.point).dot(wall.normal)));
	console.log('wall is collision');
	document.getElementById('wallCollisionSuond').play();
	}
  }
  
  console.log('puck = ' + puck.pos.x);
  
  if(puck.pos.z < -305 && puck.pos.x > -30 && puck.pos.x < 30){
  console.log('You Win');
  alert("You Win...");
  puck.pos.set (0,5,-10);
  puck.vel.set (15,0,-100);
  }
  
  if(puck.pos.z > 305 && puck.pos.x > -30 && puck.pos.x < 30){
  console.log('You lose');
  alert("You lose...");
  puck.pos.set (0,5,250);
  }
  
  puck.update (0.1);
}

function render() {

  renderer.render(scene, camera);

  endPos.copy (playerArm.children[0].children[1].localToWorld(new THREE.Vector3(90,-5,0)));
  
  end.position.copy (endPos);
  //
  endPos2.copy (opponentArm.children[0].children[1].localToWorld(new THREE.Vector3(90,-5,0)));
  
  end2.position.copy (endPos2);
}


function update() {

  // move base  
  if (Math.abs(zz) > 100) sign *= -1
  zz += 2*sign;
  
  
  playerArm.position.set (0, 0, setLength);
  
  var thetas = [playerer.theta1, playerer.theta2];
  
  // target is set by mousedown callback
  playerer.ccdSys.solve (playerer.target, thetas);
  playerer.update (thetas);
  
  //
  opponentArm.position.set (zz, 0, -setLength);
  
  var thetas = [opponent.theta1, opponent.theta2];
  
  // target is set by mousedown callback
  opponent.ccdSys.solve (opponent.target, thetas);
  opponent.update (thetas);
  

}


function onDocumentMouseMove (event) {

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);

  if (intersects.length > 0) {
    //.position.copy(intersects[0].point);
    //console.log('puck = ' + puck.pos.x + ',' + puck.pos.z);
    //console.log('pos =' + opponentArm.worldToLocal (puck.pos.clone()));	
    playerer.target.copy ( playerArm.worldToLocal (intersects[0].point) )
	
	//if(puck.pos.z < -80 && puck.pos.z > -175){
	opponent.target.copy ( opponentArm.worldToLocal (puck.pos.clone()) )
	//}
  }

}


</script>
</body>

</html>