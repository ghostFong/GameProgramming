<!DOCTYPE html>

<html>

<head>
<style>

	body {
	  font-family: Monospace;
	  background-color: #000;
	  color: #fff;
	  margin: 0px;
	  overflow: hidden;
	}

	#info {
	  color: #fff;
	  position: absolute;
	  top: 10px;
	  width: 100%;
	  text-align: center;
	  z-index: 100;
	  display: block;
	}

	#info a,
	.button {
	  color: #f00;
	  font-weight: bold;
	  text-decoration: underline;
	  cursor: pointer
	}

</style>
</head>
<!--https://stackoverflow.com/questions/43895390/imgur-images-returning-403-->
<meta name="referrer" content="no-referrer">
<body>
<div id="info">Agent and Obstacle class <br>

</div>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>



<script>

//import MTLLoader from 'three-mtl-loader';
var camera, scene, renderer;
//setGyroCamera
//var gyroCamera, useGyro = true;
//var gyro;
let texture, texture2;
let theta = 0,
  theta2 = 0;
let body, head, leftLeg, rightLeg, leftArm, rightArm;
let intKey, leftL, rightL;
let lThigh, rThigh, keys, pose1, pose2, keySlows, poseSlow1, poseSlow2;
let height = 6,
  width = 2;
let T = 1,
  cycleOneCount = 0,
  cycleTwoCount = 0;
let clock = new THREE.Clock();
let ts = clock.getElapsedTime();

let keyboard = new KeyboardState();
let pos = new THREE.Vector3();
let vel = new THREE.Vector3();
let force = new THREE.Vector3();
let busPos = new THREE.Vector3();
let busVel = new THREE.Vector3();
let busForce = new THREE.Vector3();
let power, busPower, angle, headAngle = 0, headSign = 1;
let targetMesh, raycaster, agent, pSet;
let mouse = new THREE.Vector2();
let pickables = [];
let theObject;
let mouseX = 0,
  mouseY = 0;

let windowHalfX = window.innerWidth;
let windowHalfY = window.innerHeight;
var controls;
let bs;
let modelName;
let theModel;
let angleB = 0, stopBusCycle = 0;

(function() {
  Math.clamp = function(val,min,max){
    return Math.min(Math.max(val,min),max);
    
  }})();
	
function clamp (val, min, max) { // min <= val <= max
   return Math.min(Math.max(val,min),max);
}
	//---------------------------------------------------------
	class Agent {
  constructor(pos, group) {
    this.pos = pos.clone();
    this.vel = new THREE.Vector3();
    this.force = new THREE.Vector3();
    this.target = null;
		//碰撞偵測物件寬
    this.size = width*2;
    this.model = group;
    //scene.add (group);
    
    this.MAXSPEED = 50;
    this.ARRIVAL_R = 40;
    
    // for orientable agent
    this.angle = 0;
  }
  
  update(dt) {
    this.accumulateForce();
    this.vel.add(this.force.clone().multiplyScalar(dt));

		// ARRIVAL: velocity modulation
    if (this.target !== null) {   
      let dst = this.target.distanceTo(this.pos);
			pSet = dst;
			console.log('pSet = ' + pSet);
      if (dst < this.ARRIVAL_R) {  // close enough
        this.vel.setLength(dst);
				if(pSet > 1){
				power = 60;
				//power = power - 0.1;
				}else{
				power = 0.1;
				}
      }else if(pSet < 81 && pSet > 65){
			power = 75.0;
			}else if(pSet < 66 && pSet > 39){
			power = 70.0;
			}else{
			power = 80.0;
			}
    }
    
   	// MAXSPEED modulation
		let speed = this.vel.length()
		this.vel.setLength(clamp (speed, 0, this.MAXSPEED))
		this.pos.add(this.vel.clone().multiplyScalar(dt))
    this.model.position.copy(this.pos)
    
    // for orientable agent
    // non PD version
    if (this.vel.length() > 0.1) {
	    	this.angle = Math.atan2 (-this.vel.z, this.vel.x)
    		this.model.rotation.y = this.angle
   	}
  }
  
  setTarget(x,y,z) {
  	if (this.target !== null)
    	this.target.set(x,y,z);
    else {
    	this.target = new THREE.Vector3(x,y,z);
    }
  }
  
  targetInducedForce(targetPos) { // seek
    return targetPos.clone().sub(this.pos).setLength(this.MAXSPEED).sub(this.vel);
  }

  accumulateForce() {
    if (this.target) 
    	this.force.copy(this.targetInducedForce(this.target));
  }

}
//////////////////////////////////////////////////
pose1 = {
	lThigh: Math.PI / 12,
  rThigh: -Math.PI / 12
}
pose2 = {
  lThigh: -Math.PI / 12,
  rThigh: +Math.PI / 12
}
keys = [
  [0, pose1],
  [0.5, pose2],
  [1, pose1]
];

poseSlow1 = {
	lThigh: Math.PI / 6,
  rThigh: -Math.PI / 6
}
poseSlow2 = {
  lThigh: -Math.PI / 6,
  rThigh: +Math.PI / 6
}
keySlows = [
  [0, poseSlow1],
  [0.5, poseSlow2],
  [1, poseSlow1]
];

function keyframe(t) {
  
	T = 0.5 + (80- power) * 0.0625;
	var s = ((t - ts) % T) / T;
  if(power > 0.1 && power < 31){
	//var s = ((t - ts) % (T * 2)) / (T *2);
	for (var i = 1; i < keys.length; i++) {
    if (keys[i][0] > s) break;
  }
	//console.log('keyframe power = ' + power);
  // take i-1
  var ii = i - 1;
  var a = (s - keys[ii][0]) / (keys[ii + 1][0] - keys[ii][0]);
  intKey = [keys[ii][1].lThigh * (1 - a) + keys[ii + 1][1].lThigh * a,
    keys[ii][1].rThigh * (1 - a) + keys[ii + 1][1].rThigh * a
  ];
	}
	
	if (power > 29 && power < 81){
	//var s = ((t - ts) % T) / T;
	for (var i = 1; i < keySlows.length; i++) {
    if (keySlows[i][0] > s) break;
  }
	//console.log('keyframe power = ' + power);
  // take i-1
  var ii = i - 1;
  var a = (s - keySlows[ii][0]) / (keySlows[ii + 1][0] - keySlows[ii][0]);
  intKey = [keySlows[ii][1].lThigh * (1 - a) + keySlows[ii + 1][1].lThigh * a,
    keySlows[ii][1].rThigh * (1 - a) + keySlows[ii + 1][1].rThigh * a
  ];
	}
	
  return intKey;
}
////////////////////////////////////////////////////////////////////
$('#switch').click(function() {
  useGyro = !useGyro;
  if (useGyro) $('#switch').text('using useGyro')
  else $('#switch').text('switch view')
})

////////////////////////////////////////////////////////////////////

init();
animate();

function init() {


  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  //camera.position.z = 500;
  camera.position.set(0, 200, 200);

//gyro
//gyroCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
//gyroCamera.position.z = 200;


  controls = new THREE.OrbitControls(camera, renderer.domElement);
	
	//let controlsG = new OrbitControls(gyroCamera, renderer.domElement);
	
  let loaderScenes = new THREE.TextureLoader();
  
  targetMesh = readModel('myBus');
  //var gridXZ = new THREE.GridHelper(340, 24, 'red', 'white');
  //scene.add(gridXZ);
	let plane = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.5,
    visible: true
  }));
  scene.add(plane);
  plane.material.visible = false
  plane.rotation.x = -Math.PI / 2;
  pickables = [plane];
	
  texture2 = loaderScenes.load('https://i.imgur.com/U1Onvx6.png');
  var texMat = new THREE.MeshBasicMaterial({
    map: texture2
  });
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), texMat);
  scene.add(floor);

  floor.rotation.x = Math.PI * (3 / 2);
  
  ////////////////////////////////////////////////////////
  
  /*
  let loaderp = new THREE.TextureLoader();
  let texp = loaderp.load ("https://i.imgur.com/GmthNU8.png");
  targetMesh = new THREE.Mesh(new THREE.CircleGeometry(10,20), new THREE.MeshBasicMaterial({
    map: texp,
    transparent:true
	 }));
  scene.add(targetMesh);
  targetMesh.rotation.x = -Math.PI/2
  */
  raycaster = new THREE.Raycaster();
  document.addEventListener('pointerdown', onDocumentMouseDown, false);
	 ////////////////////////
		//let mesh = agentMesh ();
		
	
  ////////////////////////////////////////////////////////
  var loader = new THREE.TextureLoader();
  loader.setCrossOrigin('');
  texture = loader.load('https://i.imgur.com/JCiWSsE.png');
	
	//setPower setAngle
	power = 60.0;
	busPower = 5.0;
  angle = 0.0;
  //X,Y,Z = 寬高(前後)
  body = buildBody(2 * width, height, width);
  scene.add (body);
	
	//console.log('body set = ' + body.position.set(100, 0, 0));
    agent = new Agent(body.position.set(50, 0, 0), body);
  //body.position.y = 28.65; //9.55 + 19.1

  head = buildHead(2 * width, 2 * width, 2 * width);
  body.add(head);
  //head.position.y = 15.75; // (12.4/2) + 9.55
  scene.add(body);
	
  leftArm = buildLeftArm2(width, height, width);
  body.add(leftArm);
  leftArm.position.set(0, height / 2, 0);

  rightArm = buildRightArm2(width, height, width);
  body.add(rightArm);
  rightArm.position.set(0, height / 2, 0);

  leftLeg = buildLeftLeg2(width, height, width);
  body.add(leftLeg);

  rightLeg = buildRightLeg2(width, height, width);
  body.add(rightLeg);
  
  body.rotation.y = Math.PI/2;
	
  window.addEventListener('resize', onWindowResize, false);
  
}

//function
function readModel (modelName, targetSize=140) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('model/');
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('model/');
    objLoader.load(modelName+'.obj', function(object) {
		
		theObject =  unitize (object, targetSize);
		//theObject.add ( new THREE.BoxHelper (theObject) )
		theObject.name = 'OBJ'
		scene.add (theObject);
		//theObject.position.set(-100, 15, -80);
		theObject.rotation.y = Math.PI/2;
		//theObject.setRotationFromEuler (new THREE.Euler (3.1416/2, 0, -3.1416/2, 'ZYX'))

    }, onProgress, onError);

  });

}


////////////////////////////////////////
// wrap an Object3D around the given object
// so that it is centered at +Y axis
// 
function unitize (object, targetSize) {  
	
	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	
	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	
	// uniform scaling according to objSize
	var objSize = Math.max (size.x, size.y, size.z);
	var scaleSet = targetSize/objSize;
				
	var theObject =  new THREE.Object3D();
	theObject.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet, -center.z*scaleSet);
	
	return theObject;
			
}

//head
function buildHead(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  ////////////
  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  var a = {
    u: 2 * ww,
    v: hh + 5 * ww
  };
  var b = {
    u: 4 * ww,
    v: hh + 5 * ww
  };
  var c = {
    u: 6 * ww,
    v: hh + 5 * ww
  };
  var d = {
    u: 0,
    v: hh + 3 * ww
  };
  var e = {
    u: 2 * ww,
    v: hh + 3 * ww
  };
  var f = {
    u: 4 * ww,
    v: hh + 3 * ww
  };
  var g = {
    u: 6 * ww,
    v: hh + 3 * ww
  };
  var h = {
    u: 8 * ww,
    v: hh + 3 * ww
  };
  var i = {
    u: 0,
    v: hh + ww
  };
  var j = {
    u: 2 * ww,
    v: hh + ww
  };
  var k = {
    u: 4 * ww,
    v: hh + ww
  };
  var l = {
    u: 6 * ww,
    v: hh + ww
  };
  var m = {
    u: 8 * ww,
    v: hh + ww
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX(d, i, j, e)
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c



  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  let head = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  head.add(mesh);
  mesh.position.y = (height/2) + width;
  mesh.rotation.y = Math.PI/2;
  return head;
}
//body
function buildBody(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: 5 * ww,
    v: hh + ww
  };
  var b = {
    u: 7 * ww,
    v: hh + ww
  };
  var c = {
    u: 9 * ww,
    v: hh + ww
  };
  var d = {
    u: 4 * ww,
    v: hh
  };
  var e = {
    u: 5 * ww,
    v: hh
  };
  var f = {
    u: 7 * ww,
    v: hh
  };
  var g = {
    u: 8 * ww,
    v: hh
  };
  var h = {
    u: 10 * ww,
    v: hh
  };
  var i = {
    u: 4 * ww,
    v: 0
  };
  var j = {
    u: 5 * ww,
    v: 0
  };
  var k = {
    u: 7 * ww,
    v: 0
  };
  var l = {
    u: 8 * ww,
    v: 0
  };
  var m = {
    u: 10 * ww,
    v: 0
  };
  var x = {
    u: 9 * ww,
    v: hh
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, x.u / UU, x.v / VV, c.u / UU, c.v / VV); // b,f,x,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  let body = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
	mesh.rotation.y = Math.PI/2;
  body.add(mesh);
  return body;
}

//left leg
function buildLeftLeg2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: ww,
    v: hh + ww
  };
  var b = {
    u: 2 * ww,
    v: hh + ww
  };
  var c = {
    u: 3 * ww,
    v: hh + ww
  };
  var d = {
    u: 0,
    v: hh
  };
  var e = {
    u: ww,
    v: hh
  };
  var f = {
    u: 2 * ww,
    v: hh
  };
  var g = {
    u: 3 * ww,
    v: hh
  };
  var h = {
    u: 4 * ww,
    v: hh
  };
  var i = {
    u: 0,
    v: 0
  };
  var j = {
    u: ww,
    v: 0
  };
  var k = {
    u: 2 * ww,
    v: 0
  };
  var l = {
    u: 3 * ww,
    v: 0
  };
  var m = {
    u: 4 * ww,
    v: 0
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  let leftLeg = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  leftLeg.add(mesh);

  mesh.position.z = -width/2;
  mesh.position.y = -height;
	//mesh.rotation.y = Math.PI;
  return leftLeg;
}
//right leg

function buildRightLeg2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: ww,
    v: hh + ww
  };
  var b = {
    u: 2 * ww,
    v: hh + ww
  };
  var c = {
    u: 3 * ww,
    v: hh + ww
  };
  var d = {
    u: 0,
    v: hh
  };
  var e = {
    u: ww,
    v: hh
  };
  var f = {
    u: 2 * ww,
    v: hh
  };
  var g = {
    u: 3 * ww,
    v: hh
  };
  var h = {
    u: 4 * ww,
    v: hh
  };
  var i = {
    u: 0,
    v: 0
  };
  var j = {
    u: ww,
    v: 0
  };
  var k = {
    u: 2 * ww,
    v: 0
  };
  var l = {
    u: 3 * ww,
    v: 0
  };
  var m = {
    u: 4 * ww,
    v: 0
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  rightLeg = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  rightLeg.add(mesh);
  mesh.position.z = width / 2;
  mesh.position.y = -height;
  return rightLeg;
}


//left arm
function buildLeftArm2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: 11 * ww,
    v: hh + ww
  };
  var b = {
    u: 12 * ww,
    v: hh + ww
  };
  var c = {
    u: 13 * ww,
    v: hh + ww
  };
  var d = {
    u: 10 * ww,
    v: hh
  };
  var e = {
    u: 11 * ww,
    v: hh
  };
  var f = {
    u: 12 * ww,
    v: hh
  };
  var g = {
    u: 13 * ww,
    v: hh
  };
  var h = {
    u: 14 * ww,
    v: hh
  };
  var i = {
    u: 10 * ww,
    v: 0
  };
  var j = {
    u: 11 * ww,
    v: 0
  };
  var k = {
    u: 12 * ww,
    v: 0
  };
  var l = {
    u: 13 * ww,
    v: 0
  };
  var m = {
    u: 14 * ww,
    v: 0
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  leftArm = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  leftArm.add(mesh);
  //mesh.position.x = width * (3/2);
	mesh.position.y = -height / 2;
	mesh.position.z = -width * (3/2);
  return leftArm;
}



//right arm
function buildRightArm2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: 11 * ww,
    v: hh + ww
  };
  var b = {
    u: 12 * ww,
    v: hh + ww
  };
  var c = {
    u: 13 * ww,
    v: hh + ww
  };
  var d = {
    u: 10 * ww,
    v: hh
  };
  var e = {
    u: 11 * ww,
    v: hh
  };
  var f = {
    u: 12 * ww,
    v: hh
  };
  var g = {
    u: 13 * ww,
    v: hh
  };
  var h = {
    u: 14 * ww,
    v: hh
  };
  var i = {
    u: 10 * ww,
    v: 0
  };
  var j = {
    u: 11 * ww,
    v: 0
  };
  var k = {
    u: 12 * ww,
    v: 0
  };
  var l = {
    u: 13 * ww,
    v: 0
  };
  var m = {
    u: 14 * ww,
    v: 0
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  rightArm = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  rightArm.add(mesh);
  //mesh.position.x = -9.3;
	//mesh.position.x = width * (3/2);
	mesh.position.y = -height / 2;
	mesh.position.z = width * (3/2);
	//mesh.rotation.y = Math.PI/2;
  return rightArm;
}

//end creat UV

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onDocumentMouseDown(event) {

  //event.preventDefault();
  //mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  //mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
  //raycaster.setFromCamera(mouse, camera);
  //var intersects = raycaster.intersectObjects(pickables);
  if (busPos.length > 0) {
  /*
    targetMesh.position.copy(intersects[0].point);
    targetMesh.position.y = 0.15
	target
  */
    theObject.position.copy(busPos);
    agent.setTarget (theObject.position.x, theObject.position.y, theObject.position.z);
  }

}

function update(dt) {

  keyboard.update();
  
  if (busVel.length() > 0) {
    angle = 1.5*Math.PI + Math.atan2(busVel.x, busVel.z); 
  }

  if (keyboard.pressed("space"))  
 	  busPower = 0.1;               
  if (keyboard.pressed("up"))  
 	  busPower *= 1.2;        
  if (keyboard.pressed("down"))  
 	  if(busPower > 0.0001){
		busPower /= 1.2;
		}else{
		busPower = 0.1;
		}
 	
  busPower = Math.clamp (busPower, 0, 80.0); 
  
  
  var angle_thrust = angle;
  if (keyboard.pressed("left"))
    angle_thrust += 0.3;
  if (keyboard.pressed("right"))
    angle_thrust -= 0.3;
    
  // compute force
  var thrust = new THREE.Vector3(1,0,0).multiplyScalar(busPower).applyAxisAngle (new THREE.Vector3(0,1,0), angle_thrust);
  busForce.copy (thrust);
  busForce.add(busVel.clone().multiplyScalar(-2))
  //pos
  // eulers
  busVel.add(busForce.clone().multiplyScalar(dt));
  busPos.add(busVel.clone().multiplyScalar(dt));
}

function animate() {

	requestAnimationFrame(animate);
	render();
	
	let dt = clock.getDelta();
	agent.update(dt);
	//update(dt);
	if(theObject != undefined && stopBusCycle < 700){
	console.log('sss = ' + stopBusCycle);
	angleB += 0.02;
	console.log('theObject = ' + pos)
	theObject.position.set(80*Math.cos(angleB), 15, 80*Math.sin(angleB));
	theObject.rotation.y = -angleB;
	}
	stopBusCycle++;
	if(stopBusCycle > 1100){
	stopBusCycle = 0;
	}
	agent.setTarget (theObject.position.x, theObject.position.y, theObject.position.z);
	//body.position.copy(pos);
	body.position.y = (height+(width*2));
	
	intKey = keyframe(clock.getElapsedTime());
	if(power > 0.1){
	leftLeg.rotation.z = intKey[0];
	rightLeg.rotation.z = intKey[1];
	leftArm.rotation.z = intKey[1];
	rightArm.rotation.z = intKey[0];
	head.rotation.y = Math.PI * 2;
	}else{
	leftLeg.rotation.z = Math.PI * 2;
	rightLeg.rotation.z = Math.PI *2;
	leftArm.rotation.z = Math.PI * 2;
	rightArm.rotation.z = Math.PI * 2;
	
	headAngle += headSign*.01;
	if (Math.abs(headAngle ) > 0.75)
	headSign*= -1;
	head.rotation.y = headAngle;
	}
	
}

function render() {
  renderer.render(scene, camera);
}



</script>
</body>

</html>