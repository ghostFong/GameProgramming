<!DOCTYPE html>
<html>
<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

</style>
</head>

<body>
<div id="info">Applying Character Animation <br>
<button id='switch'>using Gyro
</button>
</div>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
</script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>


<!--<script>-->
<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.136';
import {
  OrbitControls
} from 'https://cdn.skypack.dev/three@0.136/examples/jsm/controls/OrbitControls.js';
import { Gyroscope } from "https://cdn.skypack.dev/three@0.136/examples/jsm/misc/Gyroscope.js";

var camera, scene, renderer;
//setGyroCamera
var gyroCamera, useGyro = true;
var gyro;
var texture, texture2;
var theta = 0,
  theta2 = 0;
let body, head, leftLeg, rightLeg, leftArm, rightArm;
let intKey, leftL, rightL;
let lThigh, rThigh, keys, pose1, pose2, keySlows, poseSlow1, poseSlow2;
let height = 19.1,
  width = 6.2;
let T = 1,
  cycleOneCount = 0,
  cycleTwoCount = 0;
let clock = new THREE.Clock();
let ts = clock.getElapsedTime();

var keyboard = new KeyboardState();
var pos = new THREE.Vector3();
var vel = new THREE.Vector3();
var force = new THREE.Vector3();
var power, angle, headAngle = 0, headSign = 1;

(function() {
  Math.clamp = function(val,min,max){
    return Math.min(Math.max(val,min),max);
    
  }})();
//////////////////////////////////////////////////
pose1 = {
	lThigh: Math.PI / 12,
  rThigh: -Math.PI / 12
}
pose2 = {
  lThigh: -Math.PI / 12,
  rThigh: +Math.PI / 12
}
keys = [
  [0, pose1],
  [0.5, pose2],
  [1, pose1]
];

poseSlow1 = {
	lThigh: Math.PI / 6,
  rThigh: -Math.PI / 6
}
poseSlow2 = {
  lThigh: -Math.PI / 6,
  rThigh: +Math.PI / 6
}
keySlows = [
  [0, poseSlow1],
  [0.5, poseSlow2],
  [1, poseSlow1]
];

function keyframe(t) {
  
	T = 0.5 + (80- power) * 0.0625;
	var s = ((t - ts) % T) / T;
  if(power > 0.1 && power < 31){
	//var s = ((t - ts) % (T * 2)) / (T *2);
	for (var i = 1; i < keys.length; i++) {
    if (keys[i][0] > s) break;
  }
	//console.log('keyframe power = ' + power);
  // take i-1
  var ii = i - 1;
  var a = (s - keys[ii][0]) / (keys[ii + 1][0] - keys[ii][0]);
  intKey = [keys[ii][1].lThigh * (1 - a) + keys[ii + 1][1].lThigh * a,
    keys[ii][1].rThigh * (1 - a) + keys[ii + 1][1].rThigh * a
  ];
	}
	
	if (power > 29 && power < 81){
	//var s = ((t - ts) % T) / T;
	for (var i = 1; i < keySlows.length; i++) {
    if (keySlows[i][0] > s) break;
  }
	//console.log('keyframe power = ' + power);
  // take i-1
  var ii = i - 1;
  var a = (s - keySlows[ii][0]) / (keySlows[ii + 1][0] - keySlows[ii][0]);
  intKey = [keySlows[ii][1].lThigh * (1 - a) + keySlows[ii + 1][1].lThigh * a,
    keySlows[ii][1].rThigh * (1 - a) + keySlows[ii + 1][1].rThigh * a
  ];
	}
	
  return intKey;
}
////////////////////////////////////////////////////////////////////
$('#switch').click(function() {
  useGyro = !useGyro;
  if (useGyro) $('#switch').text('using useGyro')
  else $('#switch').text('switch view')
})

////////////////////////////////////////////////////////////////////

init();
animate();

function init() {


  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  //camera.position.z = 500;
  camera.position.set(0, 200, 200);

//gyro
gyroCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
gyroCamera.position.z = 200;


  let controls = new OrbitControls(camera, renderer.domElement);
	
	let controlsG = new OrbitControls(gyroCamera, renderer.domElement);
	
  let loaderScenes = new THREE.TextureLoader();

  texture2 = loaderScenes.load('https://i.imgur.com/U1Onvx6.png');
  var texMat = new THREE.MeshBasicMaterial({
    map: texture2
  });
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), texMat);
  scene.add(floor);
  floor.rotation.x = Math.PI * (3 / 2);

  ////////////////////////////////////////////////////////
  var loader = new THREE.TextureLoader();
  loader.setCrossOrigin('');
  texture = loader.load('https://i.imgur.com/JCiWSsE.png');
	
	//setPower setAngle
	power = 5.0;
  angle = 0.0;
  //X,Y,Z = 寬高(前後)
  body = buildBody2(2 * width, height, width);
  //scene.add (body);
  //body.position.y = 28.65; //9.55 + 19.1

  head = buildHead2(2 * width, 2 * width, 2 * width);
  body.add(head);
  //head.position.y = 15.75; // (12.4/2) + 9.55
  scene.add(body);
	
  leftArm = buildLeftArm2(width, height, width);
  body.add(leftArm);
  leftArm.position.set(0, height / 2, 0);

  rightArm = buildRightArm2(width, height, width);
  body.add(rightArm);
  rightArm.position.set(0, height / 2, 0);

  leftLeg = buildLeftLeg2(width, height, width);
  body.add(leftLeg);

  rightLeg = buildRightLeg2(width, height, width);
  body.add(rightLeg);
	
	body.rotation.y = Math.PI/2;
	
	gyro = new Gyroscope();
	body.add (gyro);
	gyro.add (gyroCamera);
	
  window.addEventListener('resize', onWindowResize, false);
}

//function
//head
function buildHead2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  ////////////
  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  var a = {
    u: 2 * ww,
    v: hh + 5 * ww
  };
  var b = {
    u: 4 * ww,
    v: hh + 5 * ww
  };
  var c = {
    u: 6 * ww,
    v: hh + 5 * ww
  };
  var d = {
    u: 0,
    v: hh + 3 * ww
  };
  var e = {
    u: 2 * ww,
    v: hh + 3 * ww
  };
  var f = {
    u: 4 * ww,
    v: hh + 3 * ww
  };
  var g = {
    u: 6 * ww,
    v: hh + 3 * ww
  };
  var h = {
    u: 8 * ww,
    v: hh + 3 * ww
  };
  var i = {
    u: 0,
    v: hh + ww
  };
  var j = {
    u: 2 * ww,
    v: hh + ww
  };
  var k = {
    u: 4 * ww,
    v: hh + ww
  };
  var l = {
    u: 6 * ww,
    v: hh + ww
  };
  var m = {
    u: 8 * ww,
    v: hh + ww
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX(d, i, j, e)
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c



  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  let head = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  head.add(mesh);
  mesh.position.y = 15.75;
	mesh.rotation.y = Math.PI/2;
  return head;
}
//body
function buildBody2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: 5 * ww,
    v: hh + ww
  };
  var b = {
    u: 7 * ww,
    v: hh + ww
  };
  var c = {
    u: 9 * ww,
    v: hh + ww
  };
  var d = {
    u: 4 * ww,
    v: hh
  };
  var e = {
    u: 5 * ww,
    v: hh
  };
  var f = {
    u: 7 * ww,
    v: hh
  };
  var g = {
    u: 8 * ww,
    v: hh
  };
  var h = {
    u: 10 * ww,
    v: hh
  };
  var i = {
    u: 4 * ww,
    v: 0
  };
  var j = {
    u: 5 * ww,
    v: 0
  };
  var k = {
    u: 7 * ww,
    v: 0
  };
  var l = {
    u: 8 * ww,
    v: 0
  };
  var m = {
    u: 10 * ww,
    v: 0
  };
  var x = {
    u: 9 * ww,
    v: hh
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, x.u / UU, x.v / VV, c.u / UU, c.v / VV); // b,f,x,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  let body = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
	mesh.rotation.y = Math.PI/2;
  body.add(mesh);
  return body;
}

//left leg
function buildLeftLeg2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: ww,
    v: hh + ww
  };
  var b = {
    u: 2 * ww,
    v: hh + ww
  };
  var c = {
    u: 3 * ww,
    v: hh + ww
  };
  var d = {
    u: 0,
    v: hh
  };
  var e = {
    u: ww,
    v: hh
  };
  var f = {
    u: 2 * ww,
    v: hh
  };
  var g = {
    u: 3 * ww,
    v: hh
  };
  var h = {
    u: 4 * ww,
    v: hh
  };
  var i = {
    u: 0,
    v: 0
  };
  var j = {
    u: ww,
    v: 0
  };
  var k = {
    u: 2 * ww,
    v: 0
  };
  var l = {
    u: 3 * ww,
    v: 0
  };
  var m = {
    u: 4 * ww,
    v: 0
  };

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  let leftLeg = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  leftLeg.add(mesh);

  mesh.position.z = -width/2;
  mesh.position.y = -height;
	//mesh.rotation.y = Math.PI;
  return leftLeg;
}
//right leg

function buildRightLeg2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: ww,
    v: hh + ww
  };
  var b = {
    u: 2 * ww,
    v: hh + ww
  };
  var c = {
    u: 3 * ww,
    v: hh + ww
  };
  var d = {
    u: 0,
    v: hh
  };
  var e = {
    u: ww,
    v: hh
  };
  var f = {
    u: 2 * ww,
    v: hh
  };
  var g = {
    u: 3 * ww,
    v: hh
  };
  var h = {
    u: 4 * ww,
    v: hh
  };
  var i = {
    u: 0,
    v: 0
  };
  var j = {
    u: ww,
    v: 0
  };
  var k = {
    u: 2 * ww,
    v: 0
  };
  var l = {
    u: 3 * ww,
    v: 0
  };
  var m = {
    u: 4 * ww,
    v: 0
  };

  /*
  var a = {u: ww, v:0};
  var b = {u: 2*ww, v:0};
  var c = {u: 3*ww, v:0};
  var d = {u: 0, v:-ww};
  var e = {u: ww, v:-ww};
  var f = {u: 2*ww, v:-ww};
  var g = {u: 3*ww, v:-ww};
  var h = {u: 4*ww, v:-ww};
  var i = {u: 0, v:-ww-hh};
  var j = {u: ww, v:-ww-hh};
  var k = {u: 2*ww, v:-ww-hh};
  var l = {u: 3*ww, v:-ww-hh};
  var m = {u: 4*ww, v:-ww-hh};
*/

  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  rightLeg = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  rightLeg.add(mesh);
  mesh.position.z = width / 2;
  mesh.position.y = -height;
  return rightLeg;
}


//left arm
function buildLeftArm2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: 11 * ww,
    v: hh + ww
  };
  var b = {
    u: 12 * ww,
    v: hh + ww
  };
  var c = {
    u: 13 * ww,
    v: hh + ww
  };
  var d = {
    u: 10 * ww,
    v: hh
  };
  var e = {
    u: 11 * ww,
    v: hh
  };
  var f = {
    u: 12 * ww,
    v: hh
  };
  var g = {
    u: 13 * ww,
    v: hh
  };
  var h = {
    u: 14 * ww,
    v: hh
  };
  var i = {
    u: 10 * ww,
    v: 0
  };
  var j = {
    u: 11 * ww,
    v: 0
  };
  var k = {
    u: 12 * ww,
    v: 0
  };
  var l = {
    u: 13 * ww,
    v: 0
  };
  var m = {
    u: 14 * ww,
    v: 0
  };
  /*
	a:11w, h+w       f:12w, h         k:12w, 0
	b:12w, h+w       g:13w, h         l:13w, 0
	c:13w, h+w       h:14w, h         m:14w, 0
	d:10w, h         i:10w, 0
	e:11w, h         j:11w, 0
*/
  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  leftArm = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  leftArm.add(mesh);
  //mesh.position.x = width * (3/2);
	mesh.position.y = -height / 2;
	mesh.position.z = -width * (3/2);
  return leftArm;
}



//right arm
function buildRightArm2(WW, HH, DD) {

  var geometry = new THREE.BufferGeometry();
  var vertices = [];
  var indices = [];
  var uvs = [];

  const ww = 1;
  const hh = 3;
  const UU = 14 * ww;
  const VV = hh + 5 * ww;

  //var a = {u: 2*ww, v: hh+5*ww};
  var a = {
    u: 11 * ww,
    v: hh + ww
  };
  var b = {
    u: 12 * ww,
    v: hh + ww
  };
  var c = {
    u: 13 * ww,
    v: hh + ww
  };
  var d = {
    u: 10 * ww,
    v: hh
  };
  var e = {
    u: 11 * ww,
    v: hh
  };
  var f = {
    u: 12 * ww,
    v: hh
  };
  var g = {
    u: 13 * ww,
    v: hh
  };
  var h = {
    u: 14 * ww,
    v: hh
  };
  var i = {
    u: 10 * ww,
    v: 0
  };
  var j = {
    u: 11 * ww,
    v: 0
  };
  var k = {
    u: 12 * ww,
    v: 0
  };
  var l = {
    u: 13 * ww,
    v: 0
  };
  var m = {
    u: 14 * ww,
    v: 0
  };
  /*
	a:11w, h+w       f:12w, h         k:12w, 0
	b:12w, h+w       g:13w, h         l:13w, 0
	c:13w, h+w       h:14w, h         m:14w, 0
	d:10w, h         i:10w, 0
	e:11w, h         j:11w, 0
*/
  // PZ
  vertices.push(-WW / 2, HH / 2, DD / 2, -WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, HH / 2, DD / 2); // 0,3,2,1
  indices.push(0, 1, 2, 0, 2, 3);
  uvs.push(e.u / UU, e.v / VV, j.u / UU, j.v / VV, k.u / UU, k.v / VV, f.u / UU, f.v / VV); // e,j,k,f

  // PX
  vertices.push(WW / 2, HH / 2, DD / 2, WW / 2, -HH / 2, DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, HH / 2, -DD / 2); // 1,2,6,5
  indices.push(4, 5, 6, 4, 6, 7); // [0,1,2, 0,2,3] + 4
  uvs.push(f.u / UU, f.v / VV, k.u / UU, k.v / VV, l.u / UU, l.v / VV, g.u / UU, g.v / VV); // f,k,l,g

  // NX
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, DD / 2, -WW / 2, HH / 2, DD / 2); // 4,7,3,0
  indices.push(8, 9, 10, 8, 10, 11); // [0,1,2, 0,2,3] + 8
  uvs.push(d.u / UU, d.v / VV, i.u / UU, i.v / VV, j.u / UU, j.v / VV, e.u / UU, e.v / VV); // d,i,j,e

  // NZ
  vertices.push(WW / 2, HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, -WW / 2, -HH / 2, -DD / 2, -WW / 2, HH / 2, -DD / 2); // 5,6,7,4
  indices.push(12, 13, 14, 12, 14, 15); // [0,1,2, 0,2,3] + 12
  uvs.push(g.u / UU, g.v / VV, l.u / UU, l.v / VV, m.u / UU, m.v / VV, h.u / UU, h.v / VV); // g,l,m,h

  // PY
  vertices.push(-WW / 2, HH / 2, -DD / 2, -WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, DD / 2, WW / 2, HH / 2, -DD / 2); // 4, 0, 1, 5 0451
  //indices.push (16,17,18, 19,20,21); // [0,1,2, 0,2,3] + 16
  indices.push(16, 17, 18, 16, 18, 19); // [0,1,2, 0,2,3] + 16
  uvs.push(a.u / UU, a.v / VV, e.u / UU, e.v / VV, f.u / UU, f.v / VV, b.u / UU, b.v / VV); // a,e,f,b

  // NY
  vertices.push(-WW / 2, -HH / 2, DD / 2, -WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, -DD / 2, WW / 2, -HH / 2, DD / 2); // 3,7,6,2
  indices.push(20, 21, 22, 20, 22, 23); // [0,1,2, 0,2,3] + 20
  uvs.push(b.u / UU, b.v / VV, f.u / UU, f.v / VV, g.u / UU, g.v / VV, c.u / UU, c.v / VV); // b,f,g,c

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  rightArm = new THREE.Group();
  let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  rightArm.add(mesh);
  //mesh.position.x = -9.3;
	//mesh.position.x = width * (3/2);
	mesh.position.y = -height / 2;
	mesh.position.z = width * (3/2);
	//mesh.rotation.y = Math.PI/2;
  return rightArm;
}

//end creat UV


//upDate
function update(dt) {

  keyboard.update();
  
  if (vel.length() > 0) {
    angle = 1.5*Math.PI + Math.atan2(vel.x, vel.z); 
  }

  if (keyboard.pressed("space"))  
 	  power = 0.1;               
  if (keyboard.pressed("up"))  
 	  power *= 1.2;        
  if (keyboard.pressed("down"))  
 	  if(power > 0.0001){
		power /= 1.2;
		}else{
		power = 0.1;
		}
 	
  power = Math.clamp (power, 0, 80.0); 
  
  
  var angle_thrust = angle;
  if (keyboard.pressed("left"))
    angle_thrust += 0.3;
  if (keyboard.pressed("right"))
    angle_thrust -= 0.3;
    
  // compute force
  var thrust = new THREE.Vector3(1,0,0).multiplyScalar(power).applyAxisAngle (new THREE.Vector3(0,1,0), angle_thrust);
  force.copy (thrust);
  force.add(vel.clone().multiplyScalar(-2))

  // eulers
  vel.add(force.clone().multiplyScalar(dt));
  pos.add(vel.clone().multiplyScalar(dt));
}







function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {

  //render();

  let dt = clock.getDelta();
	update(dt);
  
	body.position.copy(pos);
	body.position.y = 28.65;
  body.rotation.y = angle;
	
  intKey = keyframe(clock.getElapsedTime());
  if(power > 0.1){
	leftLeg.rotation.z = intKey[0];
  rightLeg.rotation.z = intKey[1];
  leftArm.rotation.z = intKey[1];
  rightArm.rotation.z = intKey[0];
	head.rotation.y = Math.PI * 2;
	}else{
	leftLeg.rotation.z = Math.PI * 2;
  rightLeg.rotation.z = Math.PI *2;
  leftArm.rotation.z = Math.PI * 2;
  rightArm.rotation.z = Math.PI * 2;
	
	headAngle += headSign*.01;
  if (Math.abs(headAngle ) > 0.75)
  headSign*= -1;
  head.rotation.y = headAngle;
	}
	
	
	camera.lookAt (body.position);
	requestAnimationFrame(animate);
	
	if (useGyro)
	renderer.render(scene, gyroCamera);
	else
	renderer.render(scene, camera);
	
  
}

function render() {
  renderer.render(scene, camera);
}



</script>
</body>

</html>