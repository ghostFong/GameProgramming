<!DOCTYPE html>
<html>
<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

</style>
</head>

<body>
<div id="info">Game Physics <br>
<!-- button -->
<button id="play" style="width:20%">Play</button> 
</div>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<!-- music source from https://www.tam-music.com/ -->
<audio id="puckCollisionSuond" style="display:none">
<source src="https://www.tam-music.com/se/menu/wave/short01d.wav" type='audio/wav'>
</audio>
<audio id="wallCollisionSuond" style="display:none">
<source src="https://www.tam-music.com/se/menu/wave/cursor5.wav" type='audio/wav'>
</audio>
<audio id="relaxed" autoplay loop style="display:none">
<source src="https://www.tam-music.com/mp3/tamhe15.mp3"  type='audio/mp3'>
</audio>

<script>

$('#play').click(function() {
  isPaused = !isPaused;
  if (isPaused) {
    $('#play').text('Play')
    relaxed.pause()
  } else {
    $('#play').text('Pause')
    relaxed.play()
  }
});

var camera, scene, renderer;
var puckLight;
var pucks = [];
var walls = [];
var dt = 0.1;
//var pos, vel, force;
const R = 4;
const wallSet = 100;
var eps = 1e-3; //0.001
var cR = 1.0;

var isDimming = false,
  soundVal = 1.0;
var isPaused = true;
var relaxed, puckCollisionSuond, wallCollisionSuond;




class threePosition {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
}

class Puck {
  constructor(position, size, color) {

    this.puckLight = new THREE.PointLight(color, 1, 150, 3);
    this.obj = new THREE.Mesh(new THREE.CylinderGeometry(size.x, size.x, size.y, size.z), new THREE.MeshBasicMaterial({
      color
    }));
    scene.add(this.obj);
    //this.obj.material.color = new THREE.Color().setHSL (this.color, 0.8, 0.3);
    this.obj.position.y = size.y / 2;


    scene.add(this.puckLight);

    this.pos = new THREE.Vector3(position.x, position.y, position.z);
    this.vel = new THREE.Vector3(Math.random() * 6 + 1, 0, Math.random() * 6 + 1);
    this.force = new THREE.Vector3(0, 0, 0);

  }

  calculateWall(wall) {
    if (this.pos.clone().sub(wall.point).dot(wall.normal) < eps + R) {
      var vN = wall.normal.clone().multiplyScalar(this.vel.dot(wall.normal));
      var vT = this.vel.clone().sub(vN);
      this.vel.copy(vT.add(vN.multiplyScalar(-cR)));
      this.pos.add(wall.normal.clone().multiplyScalar(R - this.pos.clone().sub(wall.point).dot(wall.normal)));
      return true;
    }
    return false;
  }

  calculatePuck(puck) {
    if (this.pos.clone().sub(puck.pos).length() < 2 * R) {
      var posDist = this.pos.distanceTo(puck.pos);
      var p1minp2 = this.pos.clone().add(puck.pos.clone().multiplyScalar(-1));
      var v1minv2 = this.vel.clone().add(puck.vel.clone().multiplyScalar(-1));
      var p2minp1 = puck.pos.clone().add(this.pos.clone().multiplyScalar(-1));
      var v2minv1 = puck.vel.clone().add(this.vel.clone().multiplyScalar(-1));
      this.vel.add(p1minp2.multiplyScalar(-v1minv2.dot(p1minp2) / posDist / posDist));
      this.pos.add(p1minp2.multiplyScalar(R - posDist / 2));

      puck.vel.add(p2minp1.multiplyScalar(-v2minv1.dot(p2minp1) / posDist / posDist));
      puck.pos.add(p2minp1.multiplyScalar(R - posDist / 2));

      return true;
    }
    return false;
  }


}

class Wall {
  constructor(position, size) {
    this.obj = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), new THREE.MeshPhongMaterial({
      color: 'lightgrey',
      transparent: true,
      opacity: 0.6
    }));
    this.obj.position.set(position.x, position.y, position.z);
    let tmp = 0;
    if (position.x == -wallSet || position.z == -wallSet) {
      tmp = (-wallSet + 1) + R;
    } else tmp = (wallSet - 1) - R;
    if (position.x == -wallSet || position.x == wallSet) {
      this.point = new THREE.Vector3(tmp, 0, 0);
      this.normal = new THREE.Vector3(-1 * tmp / Math.abs(tmp), 0, 0);
      if (position.x > 0 && position.z == 0) {
        this.obj.rotation.y = -Math.PI;
      }
    } else {
      this.point = new THREE.Vector3(0, 0, tmp);
      this.normal = new THREE.Vector3(0, 0, -1 * tmp / Math.abs(tmp));
    }
    scene.add(this.obj);
  }
}

//////////////////////////////////////////////////
init();
animate();

function init() {

  puckCollisionSuond = document.getElementById('puckCollisionSuond');
  wallCollisionSuond = document.getElementById('wallCollisionSuond');
  relaxed = document.getElementById('relaxed');

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  //camera = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 100);
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(0, 100, 150);
	//camera.position.set = (0, 500, 300);
  let controls = new THREE.OrbitControls(camera, renderer.domElement);
	
	//floorSet
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200, 3, 3), new THREE.MeshPhongMaterial({
    color: 'grey',
    transparent: false,
    opacity: 0.7,
    side: THREE.DoubleSide
  }));
  scene.add(floor);
  floor.rotation.x = -Math.PI / 2;

  //puckSet
  pucks = [
    new Puck(new threePosition(0, 0, 0), new threePosition(R, 2, 16), 0xf7da45),
    new Puck(new threePosition(200, 0, 0), new threePosition(R, 2, 16), 0x8ff745),
    new Puck(new threePosition(-30, 0, -25), new threePosition(R, 2, 16), 0x45e8f7),
    new Puck(new threePosition(60, 0, -30), new threePosition(R, 2, 16), 0x4e45f7),
    new Puck(new threePosition(-40, 0, 0), new threePosition(R, 2, 16), 0x9e45f7),
    new Puck(new threePosition(-60, 0, 15), new threePosition(R, 2, 16), 0xc91a1a)
  ]
  console.log(pucks[1])
  var light = new THREE.AmbientLight(0x202020);
  scene.add(light);



  walls = [
    new Wall(new threePosition(-wallSet, 25, 0), new threePosition(10, 50, (wallSet * 2) + 10)),
    new Wall(new threePosition(wallSet, 25, 0), new threePosition(-10, 50, (wallSet * 2) + 10)),
    new Wall(new threePosition(0, 25, wallSet), new threePosition((wallSet * 2) - 10, 50, 10)),
    new Wall(new threePosition(0, 25, -wallSet), new threePosition((wallSet * 2) - 10, 50, 10))
  ]
  //walls[1].obj.rotation.y = -Math.PI/2;

  window.addEventListener('resize', onWindowResize, false);
  //window.addEventListener('mousedown', onDocumentMouseDown, false);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}


function animate() {

  relaxed.volume = soundVal;
  for (i = 0; i < pucks.length; i++) {
    let puck = pucks[i];
    puck.vel.add(puck.force.clone().multiplyScalar(dt));
    puck.pos.add(puck.vel.clone().multiplyScalar(dt));
    puck.obj.position.copy(puck.pos);
    puck.obj.position.y += 4;
    puck.puckLight.position.copy(puck.pos);
    puck.puckLight.position.y += 10;
  }


  for (i = 0; i < walls.length; i++) {
    let wall = walls[i];
    for (j = 0; j < pucks.length; j++) {
      let puck = pucks[j];
      collision = puck.calculateWall(wall);
      if (collision) {
        document.getElementById('wallCollisionSuond').play();
        console.log('wall is collision');
      }
    }
  }


  for (i = 0; i < pucks.length - 1; i++) {
    for (j = i + 1; j < pucks.length; j++) {
      let puck1 = pucks[i];
      let puck2 = pucks[j];
      collision = puck1.calculatePuck(puck2);
      //console.log(collision);
      if (collision) {
        document.getElementById('puckCollisionSuond').play();
        console.log('puck is collision');
      }
    }
  }

  requestAnimationFrame(animate);
  render();
}

function render() {
  renderer.render(scene, camera);
}

</script>
</body>

</html>